--- ../../alsa-kernel/pcmcia/vx/vxpocket.c	2005-08-23 20:19:39.000000000 +0200
+++ vxpocket.c	2005-08-25 14:04:41.000000000 +0200
@@ -1,3 +1,4 @@
+#include "vx_entry.inc"
 /*
  * Driver for Digigram VXpocket V2/440 soundcards
  *
@@ -23,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
+#include "compat_cs.h"
 #include "vxpocket.h"
 #include <pcmcia/ciscode.h>
 #include <pcmcia/cisreg.h>
@@ -88,6 +90,9 @@
 	vx_core_t *chip = device->device_data;
 
 	snd_vx_free_firmware(chip);
+#ifndef handle_to_dev
+	kfree(chip->dev);
+#endif
 	kfree(chip);
 	return 0;
 }
@@ -158,6 +163,21 @@
 	if (! chip)
 		return NULL;
 
+#ifdef SND_VX_FW_LOADER
+#ifndef handle_to_dev
+	/* fake a device here since pcmcia doesn't give a valid device... */
+	chip->dev = kzalloc(sizeof(*chip->dev), GFP_KERNEL);
+	if (! chip->dev) {
+		snd_printk(KERN_ERR "vxp: can't malloc chip->dev\n");
+		kfree(chip);
+		snd_card_free(card);
+		return NULL;
+	}
+	device_initialize(chip->dev);
+	sprintf(chip->dev->bus_id, "vxpocket%d", chip->card->number);
+#endif
+#endif
+
 	if (snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops) < 0) {
 		kfree(chip);
 		return NULL;
@@ -178,6 +198,11 @@
 	link->irq.Handler = &snd_vx_irq_handler;
 	link->irq.Instance = chip;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) /* correct version? */
+	link->release.function = (void (*)(unsigned long))vxpocket_release;
+	link->release.data = (u_long)link;
+#endif
+
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.Vcc = 50;
 	link->conf.IntType = INT_MEMORY_AND_IO;
@@ -296,8 +321,12 @@
 	CS_CHECK(RequestIRQ, pcmcia_request_irq(link->handle, &link->irq));
 	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link->handle, &link->conf));
 
+#ifdef SND_VX_FW_LOADER
+#ifdef handle_to_dev
 	chip->dev = &handle_to_dev(link->handle);
 	snd_card_set_dev(chip->card, chip->dev);
+#endif
+#endif
 
 	if (snd_vxpocket_assign_resources(chip, link->io.BasePort1, link->irq.AssignedIRQ) < 0)
 		goto failed;
@@ -330,8 +359,12 @@
 	case CS_EVENT_CARD_REMOVAL:
 		snd_printdd(KERN_DEBUG "CARD_REMOVAL..\n");
 		link->state &= ~DEV_PRESENT;
-		if (link->state & DEV_CONFIG)
+		if (link->state & DEV_CONFIG) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) /* correct version? */
+			mod_timer(&link->release, jiffies + HZ/20);
+#endif
 			chip->chip_status |= VX_STAT_IS_STALE;
+		}
 		break;
 	case CS_EVENT_CARD_INSERTION:
 		snd_printdd(KERN_DEBUG "CARD_INSERTION..\n");
@@ -438,6 +471,10 @@
 			break;
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) /* correct version? */
+	del_timer(&link->release);
+#endif
+
 	chip->chip_status |= VX_STAT_IS_STALE; /* to be sure */
 	snd_card_disconnect(chip->card);
 	vxpocket_release(link);
@@ -448,11 +485,13 @@
  * Module entry points
  */
 
+#ifdef PCMCIA_DEVICE_MANF_CARD
 static struct pcmcia_device_id vxp_ids[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x01f1, 0x0100),
 	PCMCIA_DEVICE_NULL
 };
 MODULE_DEVICE_TABLE(pcmcia, vxp_ids);
+#endif
 
 static struct pcmcia_driver vxp_cs_driver = {
 	.owner		= THIS_MODULE,
@@ -461,8 +500,10 @@
 	},
 	.attach		= vxpocket_attach,
 	.detach		= vxpocket_detach,
+#ifdef PCMCIA_DEVICE_MANF_CARD
 	.event		= vxpocket_event,
 	.id_table	= vxp_ids,
+#endif
 };
 
 static int __init init_vxpocket(void)
@@ -478,3 +519,7 @@
 
 module_init(init_vxpocket);
 module_exit(exit_vxpocket);
+
+EXPORT_NO_SYMBOLS;
+
+#include "vx_entry.inc1"
