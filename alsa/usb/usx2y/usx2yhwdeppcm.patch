--- ../../alsa-kernel/usb/usx2y/usx2yhwdeppcm.c	2005-11-13 15:19:25.000000000 +0100
+++ usx2yhwdeppcm.c	2005-11-13 19:08:23.000000000 +0100
@@ -1,3 +1,14 @@
+#include <linux/config.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+#define SND_NEED_USB_SET_INTERFACE
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define SND_NEED_USB_WRAPPER
+#endif
+#define __NO_VERSION__
+#endif
+
 /*
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -150,7 +161,11 @@
 {
 	int pack;
 	for (pack = 0; pack < nr_of_packs(); ++pack) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 20)
 		struct usb_iso_packet_descriptor *desc = urb->iso_frame_desc + pack;
+#else
+		iso_packet_descriptor_t *desc = urb->iso_frame_desc + pack;
+#endif
 		if (NULL != subs) {
 			struct snd_usX2Y_hwdep_pcm_shm *shm = subs->usX2Y->hwdep_pcm_shm;
 			int head = shm->captured_iso_head + 1;
@@ -226,7 +241,11 @@
 }
 
 
+#ifndef OLD_USB
 static void i_usX2Y_usbpcm_urb_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void i_usX2Y_usbpcm_urb_complete(struct urb *urb)
+#endif
 {
 	struct snd_usX2Y_substream *subs = urb->context;
 	struct usX2Ydev *usX2Y = subs->usX2Y;
@@ -294,7 +313,11 @@
 	usX2Y->prepare_subs = NULL;
 }
 
+#ifndef OLD_USB
 static void i_usX2Y_usbpcm_subs_startup(struct urb *urb, struct pt_regs *regs)
+#else
+static void i_usX2Y_usbpcm_subs_startup(struct urb *urb)
+#endif
 {
 	struct snd_usX2Y_substream *subs = urb->context;
 	struct usX2Ydev *usX2Y = subs->usX2Y;
@@ -311,7 +334,11 @@
 		wake_up(&usX2Y->prepare_wait_queue);
 	}
 
+#ifndef OLD_USB
 	i_usX2Y_usbpcm_urb_complete(urb, regs);
+#else
+	i_usX2Y_usbpcm_urb_complete(urb);
+#endif
 }
 
 /*
@@ -688,22 +715,39 @@
 }
 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 static struct page * snd_usX2Y_hwdep_pcm_vm_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+static struct page * snd_usX2Y_hwdep_pcm_vm_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#else
+static unsigned long snd_usX2Y_hwdep_pcm_vm_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#endif
 {
 	unsigned long offset;
 	struct page *page;
 	void *vaddr;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 25)
 	offset = area->vm_pgoff << PAGE_SHIFT;
+#else
+	offset = area->vm_offset;
+#endif
 	offset += address - area->vm_start;
 	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
 	vaddr = (char*)((struct usX2Ydev *)area->vm_private_data)->hwdep_pcm_shm + offset;
 	page = virt_to_page(vaddr);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 	if (type)
 		*type = VM_FAULT_MINOR;
+#endif
 
+#ifndef LINUX_2_2
 	return page;
+#else
+#undef page_address
+	return page_address(page);
+#endif
 }
 
 
@@ -732,8 +776,14 @@
 		return -ENODEV;
 	}
 	area->vm_ops = &snd_usX2Y_hwdep_pcm_vm_ops;
+#ifdef VM_RESERVED
 	area->vm_flags |= VM_RESERVED;
+#endif
+#ifndef LINUX_2_2
 	area->vm_private_data = hw->private_data;
+#else
+	area->vm_private_data = (long)hw->private_data;
+#endif
 	return 0;
 }
 
