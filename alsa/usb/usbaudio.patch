--- ../alsa-kernel/usb/usbaudio.c	2005-04-20 11:05:58.000000000 +0200
+++ usbaudio.c	2005-04-20 11:07:26.000000000 +0200
@@ -1,3 +1,4 @@
+#include "usbaudio.inc"
 /*
  *   (Tentative) USB Audio Driver for ALSA
  *
@@ -67,7 +68,12 @@
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 }; /* Vendor ID for this card */
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 }; /* Product ID for this card */
 static int nrpacks = 4;		/* max. number of packets per urb */
-static int async_unlink = 1;
+static int async_unlink =
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+1;
+#else
+0; /* disabled as default for buggy async-unlink handling */
+#endif
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@ -1902,8 +1908,13 @@
 			return -ENOMEM;
 		memcpy(buf, data, size);
 	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 12)
 	err = usb_control_msg(dev, pipe, request, requesttype,
 			      value, index, buf, size, timeout);
+#else
+	err = usb_control_msg(dev, pipe, request, requesttype,
+			      value, index, buf, size, timeout * HZ / 1000);
+#endif
 	if (size > 0) {
 		memcpy(data, buf, size);
 		kfree(buf);
@@ -1916,9 +1927,11 @@
  * entry point for linux usb interface
  */
 
+#ifndef OLD_USB
 static int usb_audio_probe(struct usb_interface *intf,
 			   const struct usb_device_id *id);
 static void usb_audio_disconnect(struct usb_interface *intf);
+#endif
 
 static struct usb_device_id usb_audio_ids [] = {
 #include "usbquirks.h"
@@ -1931,10 +1944,15 @@
 MODULE_DEVICE_TABLE (usb, usb_audio_ids);
 
 static struct usb_driver usb_audio_driver = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 70)	/* FIXME: find right number */
 	.owner =	THIS_MODULE,
+#endif
 	.name =		"snd-usb-audio",
 	.probe =	usb_audio_probe,
 	.disconnect =	usb_audio_disconnect,
+#ifdef OLD_USB
+	.driver_list =	LIST_HEAD_INIT(usb_audio_driver.driver_list), 
+#endif
 	.id_table =	usb_audio_ids,
 };
 
@@ -2186,13 +2204,25 @@
 static int is_big_endian_format(struct usb_device *dev, struct audioformat *fp)
 {
 	/* M-Audio */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	if (le16_to_cpu(dev->descriptor.idVendor) == 0x0763) {
+#else
+	if (dev->descriptor.idVendor == 0x0763) {
+#endif
 		/* Quattro: captured data only */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(dev->descriptor.idProduct) == 0x2001 &&
+#else
+		if (dev->descriptor.idProduct == 0x2001 &&
+#endif
 		    fp->endpoint & USB_DIR_IN)
 			return 1;
 		/* Audiophile USB */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(dev->descriptor.idProduct) == 0x2003)
+#else
+		if (dev->descriptor.idProduct == 0x2003)
+#endif
 			return 1;
 	}
 	return 0;
@@ -2256,8 +2286,13 @@
 		break;
 	case USB_AUDIO_FORMAT_PCM8:
 		/* Dallas DS4201 workaround */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(dev->descriptor.idVendor) == 0x04fa &&
 		    le16_to_cpu(dev->descriptor.idProduct) == 0x4201)
+#else
+		if (dev->descriptor.idVendor == 0x04fa &&
+		    dev->descriptor.idProduct == 0x4201)
+#endif
 			pcm_format = SNDRV_PCM_FORMAT_S8;
 		else
 			pcm_format = SNDRV_PCM_FORMAT_U8;
@@ -2425,8 +2460,13 @@
 	/* extigy apparently supports sample rates other than 48k
 	 * but not in ordinary way.  so we enable only 48k atm.
 	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	if (le16_to_cpu(dev->descriptor.idVendor) == 0x041e && 
 	    le16_to_cpu(dev->descriptor.idProduct) == 0x3000) {
+#else
+	if (dev->descriptor.idVendor == 0x041e && 
+	    dev->descriptor.idProduct == 0x3000) {
+#endif
 		if (fmt[3] == USB_FORMAT_TYPE_I &&
 		    stream == SNDRV_PCM_STREAM_PLAYBACK &&
 		    fp->rates != SNDRV_PCM_RATE_48000)
@@ -2460,7 +2500,11 @@
 		    (altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIO_STREAMING &&
 		     altsd->bInterfaceSubClass != USB_SUBCLASS_VENDOR_SPEC) ||
 		    altsd->bNumEndpoints < 1 ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		    le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) == 0)
+#else
+		    get_endpoint(alts, 0)->wMaxPacketSize == 0)
+#endif
 			continue;
 		/* must be isochronous */
 		if ((get_endpoint(alts, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=
@@ -2523,14 +2567,23 @@
 		fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
 		fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
 		/* FIXME: decode wMaxPacketSize of high bandwith endpoints */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+#else
+		fp->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
+#endif
 		fp->attributes = csep[3];
 
 		/* some quirks for attributes here */
 
 		/* workaround for AudioTrak Optoplay */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(dev->descriptor.idVendor) == 0x0a92 &&
 		    le16_to_cpu(dev->descriptor.idProduct) == 0x0053) {
+#else
+		if (dev->descriptor.idVendor == 0x0a92 &&
+		    dev->descriptor.idProduct == 0x0053) {
+#endif
 			/* Optoplay sets the sample rate attribute although
 			 * it seems not supporting it in fact.
 			 */
@@ -2538,8 +2591,13 @@
 		}
 
 		/* workaround for M-Audio Audiophile USB */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(dev->descriptor.idVendor) == 0x0763 &&
 		    le16_to_cpu(dev->descriptor.idProduct) == 0x2003) {
+#else
+		if (dev->descriptor.idVendor == 0x0763 &&
+		    dev->descriptor.idProduct == 0x2003) {
+#endif
 			/* doesn't set the sample rate attribute, but supports it */
 			fp->attributes |= EP_CS_ATTR_SAMPLE_RATE;
 		}
@@ -2548,11 +2606,18 @@
 		 * plantronics headset and Griffin iMic have set adaptive-in
 		 * although it's really not...
 		 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if ((le16_to_cpu(dev->descriptor.idVendor) == 0x047f &&
 		     le16_to_cpu(dev->descriptor.idProduct) == 0x0ca1) ||
 		    /* Griffin iMic (note that there is an older model 77d:223) */
 		    (le16_to_cpu(dev->descriptor.idVendor) == 0x077d &&
 		     le16_to_cpu(dev->descriptor.idProduct) == 0x07af)) {
+#else
+		if ((dev->descriptor.idVendor == 0x047f &&
+		     dev->descriptor.idProduct == 0x0ca1) ||
+		    (dev->descriptor.idVendor == 0x077d &&
+		     dev->descriptor.idProduct == 0x07af)) {
+#endif
 			fp->ep_attr &= ~EP_ATTR_MASK;
 			if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 				fp->ep_attr |= EP_ATTR_ADAPTIVE;
@@ -2796,7 +2861,11 @@
 			.type = QUIRK_MIDI_FIXED_ENDPOINT,
 			.data = &ua25_ep
 		};
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		if (le16_to_cpu(chip->dev->descriptor.idProduct) == 0x002b)
+#else
+		if (chip->dev->descriptor.idProduct == 0x002b)
+#endif
 			return snd_usb_create_midi_interface(chip, iface,
 							     &ua700_quirk);
 		else
@@ -2815,7 +2884,11 @@
 	fp->iface = altsd->bInterfaceNumber;
 	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
 	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+#else
+	fp->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
+#endif
 
 	switch (fp->maxpacksize) {
 	case 0x120:
@@ -2881,7 +2954,11 @@
 	fp->iface = altsd->bInterfaceNumber;
 	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
 	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+#else
+	fp->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
+#endif
 	fp->rate_max = fp->rate_min = combine_triple(&alts->extra[8]);
 
 	stream = (fp->endpoint & USB_DIR_IN)
@@ -2939,8 +3016,13 @@
 	struct usb_host_config *config = dev->actconfig;
 	int err;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	if (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||
 	    le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {
+#else
+	if (get_cfg_desc(config)->wTotalLength == EXTIGY_FIRMWARE_SIZE_OLD ||
+	    get_cfg_desc(config)->wTotalLength == EXTIGY_FIRMWARE_SIZE_NEW) {
+#endif
 		snd_printdd("sending Extigy boot sequence...\n");
 		/* Send message to force it to reconnect with full interface. */
 		err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
@@ -2952,8 +3034,13 @@
 		if (err < 0) snd_printdd("error usb_get_descriptor: %d\n", err);
 		err = usb_reset_configuration(dev);
 		if (err < 0) snd_printdd("error usb_reset_configuration: %d\n", err);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		snd_printdd("extigy_boot: new boot length = %d\n",
 			    le16_to_cpu(get_cfg_desc(config)->wTotalLength));
+#else
+		snd_printdd("extigy_boot: new boot length = %d\n",
+			    get_cfg_desc(config)->wTotalLength);
+#endif
 		return -ENODEV; /* quit this anyway */
 	}
 	return 0;
@@ -3015,8 +3102,13 @@
 	snd_usb_audio_t *chip = entry->private_data;
 	if (! chip->shutdown)
 		snd_iprintf(buffer, "%04x:%04x\n", 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 			    le16_to_cpu(chip->dev->descriptor.idVendor),
 			    le16_to_cpu(chip->dev->descriptor.idProduct));
+#else
+			    chip->dev->descriptor.idVendor,
+			    chip->dev->descriptor.idProduct);
+#endif
 }
 
 static void snd_usb_audio_create_proc(snd_usb_audio_t *chip)
@@ -3097,8 +3189,13 @@
 
 	strcpy(card->driver, "USB-Audio");
 	sprintf(component, "USB%04x:%04x",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 		le16_to_cpu(dev->descriptor.idVendor),
 		le16_to_cpu(dev->descriptor.idProduct));
+#else
+		dev->descriptor.idVendor,
+		dev->descriptor.idProduct);
+#endif
 	snd_component_add(card, component);
 
 	/* retrieve the device string as shortname */
@@ -3110,8 +3207,13 @@
       			       card->shortname, sizeof(card->shortname)) <= 0) {
 			/* no name available from anywhere, so use ID */
 			sprintf(card->shortname, "USB Device %#04x:%#04x",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 				le16_to_cpu(dev->descriptor.idVendor),
 				le16_to_cpu(dev->descriptor.idProduct));
+#else
+				dev->descriptor.idVendor,
+				dev->descriptor.idProduct);
+#endif
 		}
 	}
 
@@ -3178,8 +3280,13 @@
 
 	/* SB Extigy needs special boot-up sequence */
 	/* if more models come, this will go to the quirk list. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 	if (le16_to_cpu(dev->descriptor.idVendor) == 0x041e && 
 	    le16_to_cpu(dev->descriptor.idProduct) == 0x3000) {
+#else
+	if (dev->descriptor.idVendor == 0x041e && 
+	    dev->descriptor.idProduct == 0x3000) {
+#endif
 		if (snd_usb_extigy_boot_quirk(dev, intf) < 0)
 			goto __err_val;
 		config = dev->actconfig;
@@ -3213,8 +3320,13 @@
 		}
 		for (i = 0; i < SNDRV_CARDS; i++)
 			if (enable[i] && ! usb_chip[i] &&
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
 			    (vid[i] == -1 || vid[i] == le16_to_cpu(dev->descriptor.idVendor)) &&
 			    (pid[i] == -1 || pid[i] == le16_to_cpu(dev->descriptor.idProduct))) {
+#else
+			    (vid[i] == -1 || vid[i] == dev->descriptor.idVendor) &&
+			    (pid[i] == -1 || pid[i] == dev->descriptor.idProduct)) {
+#endif
 				if (snd_usb_audio_create(dev, i, quirk, &chip) < 0) {
 					goto __error;
 				}
@@ -3289,12 +3401,17 @@
 		}
 		usb_chip[chip->index] = NULL;
 		up(&register_mutex);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 		snd_card_free(card);
+#else
+		snd_card_free_in_thread(card);
+#endif
 	} else {
 		up(&register_mutex);
 	}
 }
 
+#ifndef OLD_USB
 /*
  * new 2.5 USB kernel API
  */
@@ -3315,6 +3432,8 @@
 	snd_usb_audio_disconnect(interface_to_usbdev(intf),
 				 dev_get_drvdata(&intf->dev));
 }
+#endif
+
 
 
 static int __init snd_usb_audio_init(void)
@@ -3335,3 +3454,5 @@
 
 module_init(snd_usb_audio_init);
 module_exit(snd_usb_audio_cleanup);
+
+#include "usbaudio.inc1"
