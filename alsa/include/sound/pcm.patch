--- ../../alsa-kernel/include/pcm.h	2010-01-26 16:50:53.000000000 +0100
+++ pcm.h	2010-01-26 17:01:40.000000000 +0100
@@ -272,9 +272,12 @@ struct snd_pcm_runtime {
 	snd_pcm_uframes_t avail_max;
 	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
 	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
-
+#endif
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */
 	snd_pcm_format_t format;	/* SNDRV_PCM_FORMAT_* */
@@ -284,6 +287,9 @@ struct snd_pcm_runtime {
 	snd_pcm_uframes_t period_size;	/* period size */
 	unsigned int periods;		/* periods */
 	snd_pcm_uframes_t buffer_size;	/* buffer size */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	unsigned int old_tick_time;	/* for ABI compatibility */
+#endif
 	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
 	size_t byte_align;
 	unsigned int frame_bits;
@@ -295,6 +301,10 @@ struct snd_pcm_runtime {
 	/* -- SW params -- */
 	int tstamp_mode;		/* mmap timestamp is updated */
   	unsigned int period_step;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	unsigned int old_sleep_min;	/* for ABI compatibility */
+	snd_pcm_uframes_t old_xfer_align; /* for ABI compatibility */
+#endif
 	snd_pcm_uframes_t start_threshold;
 	snd_pcm_uframes_t stop_threshold;
 	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
@@ -312,11 +322,18 @@ struct snd_pcm_runtime {
 	struct snd_pcm_mmap_control *control;
 
 	/* -- locking / scheduling -- */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
 	unsigned int twake: 1;		/* do transfer (!poll) wakeup */
-	wait_queue_head_t sleep;	/* poll sleep */
+#endif
+  	wait_queue_head_t sleep;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
 	wait_queue_head_t tsleep;	/* transfer sleep */
-	struct fasync_struct *fasync;
-
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	struct timer_list old_tick_timer;	/* for ABI compatibility */
+#endif
+  	struct fasync_struct *fasync;
+  
 	/* -- private section -- */
 	void *private_data;
 	void (*private_free)(struct snd_pcm_runtime *runtime);
@@ -331,8 +348,9 @@ struct snd_pcm_runtime {
 
 	/* -- timer -- */
 	unsigned int timer_resolution;	/* timer resolution */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	int tstamp_type;		/* timestamp type */
-
+#endif
 	/* -- DMA -- */           
 	unsigned char *dma_area;	/* DMA area */
 	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
@@ -348,6 +366,21 @@ struct snd_pcm_runtime {
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	struct snd_pcm_hwptr_log *hwptr_log;
 #endif
+
+	/* appended below for ABI compatibility */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
+	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	int tstamp_type;		/* timestamp type */
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+	unsigned int twake: 1;		/* transfer (!poll) wakeup */
+	wait_queue_head_t tsleep;	/* transfer sleep */	
+#endif
 };
 
 struct snd_pcm_group {		/* keep linked substreams */
@@ -377,6 +410,9 @@ struct snd_pcm_substream {
         /* -- timer section -- */
 	struct snd_timer *timer;		/* timer */
 	unsigned timer_running: 1;	/* time is running */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	spinlock_t already_dead_timer_lock; /* just place holder */
+#endif
 	/* -- next substream -- */
 	struct snd_pcm_substream *next;
 	/* -- linked substreams -- */
