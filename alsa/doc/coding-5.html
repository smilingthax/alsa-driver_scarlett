<HTML>
<HEAD>
<TITLE>Advanced Linux Sound Architecture - Driver: PCM - Digital Audio</TITLE>
</HEAD>
<BODY>
<A HREF="coding-4.html">Previous</A>
Next
<A HREF="coding.html#toc5">Table of Contents</A>
<HR>
<H2><A NAME="s5">5. PCM - Digital Audio</A></H2>

<P>Digital Audio related structures and function is in <I>include/pcm.h</I>
header file.</P>

<H2><A NAME="ss5.1">5.1 Variables and functions</A></H2>

<P>Variables from <I>snd_pcm_t</I> structure which must be filled:</P>
<P>
<UL>
<LI><B>info_flags</B> look to <B>SND_PCM_INFO_*</B> </LI>
<LI><B>name</B> of pcm device (for example 'CS4231')</LI>
<LI><B>playback</B> variables for playback direction</LI>
<LI><B>record</B> variables for record direction</LI>
</UL>
</P>

<P>Variables from <I>snd_pcm_t</I> structure which should be filled:</P>
<P>
<UL>
<LI><B>private_data</B> should contains pointer to private data</LI>
<LI><B>private_free</B> should free private data</LI>
</UL>
</P>

<P>Variables from <I>struct snd_stru_pcm_hardware</I> which must be filled:</P>
<P>
<UL>
<LI><B>flags</B>
<UL>
<LI><B>SND_PCM_HW_BATCH</B> - hardware does double buffering</LI>
<LI><B>SND_PCM_HW_8BITONLY</B> - hardware supports only 8-bit data (be careful - look to sb16.c)</LI>
<LI><B>SND_PCM_HW_16BITONLY</B> - hardware supports only 16-bit data (be careful - look to sb16.c)</LI>
<LI><B>SND_PCM_HW_AUTODMA</B> - hardware supports auto init dma transfer (unterminated loop)</LI>
</UL>
</LI>
<LI><B>formats</B> list of supported formats <B>SND_PCM_FMT_*</B>
<UL>
<LI>if hardware doesn't support Mu-Law - it _must_ be emulated (converted), but it can't be listed here</LI>
</UL>
</LI>
<LI><B>align</B> - if transfer block must be aligned to some value - set this mask</LI>
<LI><B>min_fragment</B> - minimal fragment in 2&circ;x</LI>
<LI><B>min_rate</B> - minimal rate in Hz</LI>
<LI><B>max_rate</B> - maximal rate in Hz</LI>
<LI><B>max_voices</B> - maximal number of voices</LI>
<LI><B>int (*open)( snd_pcm_t *pcm )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI>opens pcm direction and allocates dma buffer with <I>snd_pcm_dma_alloc</I></LI>
</UL>
</LI>
<LI><B>int (*close)( snd_pcm_t *pcm )</B>
<UL>
<LI>closes pcm direction and frees dma buffer with <I>snd_pcm_dma_free</I></LI>
</UL>
</LI>
<LI><B>void (*compute_rate)( snd_pcm_t *pcm )</B>
<UL>
<LI>computes <I>snd_pcm_channel_t -> real_rate</I> from <I>snd_pcm_channel_t -> rate</I></LI>
</UL>
</LI>
<LI><B>void (*prepare)( snd_pcm_t *pcm, unsigned char *buffer, unsigned int size, unsigned int offset, unsigned int count )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>buffer</B> pointer to dma buffer</LI>
<LI><B>size</B> used size of dma buffer</LI>
<LI><B>offset</B> offset in bytes to dma buffer
<UL>
<LI>this value is always zero if hardware supports auto init dma transfer mode</LI>
</UL>
</LI>
<LI><B>count</B> of bytes to transfer (block size)</LI>
<LI>prepares pcm direction to output/input</LI>
</UL>
</LI>
<LI><B>void (*trigger)( snd_pcm_t *pcm, int up )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>up</B> if zero - trigger down (turn off), if nonzero - trigger up (turn on)</LI>
<LI>starts or stops pcm direction</LI>
</UL>
</LI>
<LI><B>unsigned int (*pointer)( snd_pcm_t *pcm, unsigned int used_size )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>used_size</B> - used size of dma buffer</LI>
<LI>returns actual byte pointer from pcm direction</LI>
</UL>
</LI>
<LI><B>void (*dma)( snd_pcm_t *pcm, unsigned char *buffer, unsigned int offset, unsigned char *user, unsigned int count )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>buffer</B> pointer to dma buffer</LI>
<LI><B>offset</B> destonation/source offset in bytes to/from dma buffer</LI>
<LI><B>user</B> pointer to buffer in user space</LI>
<LI><B>count</B> transfer count in bytes</LI>
<LI>copies data from or to user space to or from kernel dma buffer</LI>
</UL>
</LI>
<LI><B>void (*dma_move)( snd_pcm_t *pcm, unsigned char *buffer, unsigned int dest_offset, unsigned int src_offset, unsigned int count )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>buffer</B> pointer to dma buffer</LI>
<LI><B>dest_offset</B> destonation offset in bytes to dma buffer</LI>
<LI><B>src_offset</B> source offset in bytes from dma buffer</LI>
<LI><B>count</B> transfer count</LI>
<LI>transfer areas can never be overlapped</LI>
</UL>
</LI>
<LI><B>void (*dma_neutral)( snd_pcm_t *pcm, unsigned char *buffer, unsigned offset, unsigned int count, unsigned char neutral_byte )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>buffer</B> pointer to dma buffer</LI>
<LI><B>offset</B> destonation offset in bytes to dma buffer</LI>
<LI><B>count</B> count in bytes</LI>
<LI><B>neutral_byte</B> - neutral byte</LI>
<LI>fills specified area of dma buffer with neutral byte</LI>
</UL>
</LI>
</UL>
</P>

<P>Variables from <I>struct snd_stru_pcm_hardware</I> which should be filled:</P>
<P>
<UL>
<LI><B>private_data</B> should contains pointer to private data for specified direction</LI>
<LI><B>private_free</B> should free private data</LI>
</UL>
</P>

<P>Functions list:</P>
<P>
<UL>
<LI><B>void snd_pcm_playback_dma( snd_pcm_t *pcm,
unsigned char *buffer, unsigned int offset,
unsigned char *user, unsigned int count )</B>
<UL>
<LI>standard function for playback snd_pcm_channel_t -> hw.dma</LI>
</UL>
</LI>
<LI><B>void snd_pcm_playback_dma_ulaw( snd_pcm_t *pcm,
unsigned char *buffer, unsigned int offset,
unsigned char *user, unsigned int count )</B>
<UL>
<LI>standard function for playback snd_pcm_channel_t -> hw.dma
if hardware doesn't supports Mu-Law compression</LI>
</UL>
</LI>
<LI><B>void snd_pcm_playback_dma_neutral( snd_pcm_t *pcm,
unsigned char *buffer, unsigned int of
unsigned int count,
unsigned char neutral_byte )</B>
<UL>
<LI>standard function for playback snd_pcm_channel_t -> hw.dma_neutral</LI>
</UL>
</LI>
<LI><B>void snd_pcm_record_dma( snd_pcm_t *pcm,
unsigned char *buffer, unsigned int offset,
unsigned char *user, unsigned int count )</B>
<UL>
<LI>standard function for record snd_pcm_channel_t -> hw.dma</LI>
</UL>
</LI>
<LI><B>void snd_pcm_record_dma_ulaw( snd_pcm_t *pcm,
unsigned char *buffer, unsigned int offset,
unsigned char *user, unsigned int count )</B>
<UL>
<LI>standard function for record snd_pcm_channel_t -> hw.dma
if hardware doesn't supports Mu-Law compression</LI>
</UL>
</LI>
<LI><B>void snd_pcm_dma_move( snd_pcm_t *pcm,
unsigned char *buffer,
unsigned int dest_offset, unsigned int src_offset,
unsigned int count )</B>
<UL>
<LI>standard function for snd_pcm_channel_t -> hw.dma_move</LI>
</UL>
</LI>
</UL>
</P>

<P>Functions for dma allocation:</P>
<P>
<UL>
<LI><B>int snd_pcm_dma_alloc( snd_pcm_t *pcm, int direction, int dmanum, char *ident )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>direction</B> pcm direction - <B>SND_PCM_PLAYBACK</B> or <B>SND_PCM_RECORD</B></LI>
<LI><B>dmanum</B> dma index</LI>
<LI><B>ident</B> identification for dma owner</LI>
<LI>allocates pcm dma buffer</LI>
</UL>
</LI>
<LI><B>int snd_pcm_dma_free( snd_pcm_t *pcm, int direction, int dmanum )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>direction</B> pcm direction</LI>
<LI><B>dmanum</B> dma index</LI>
<LI>frees pcm dma buffer</LI>
</UL>
</LI>
</UL>
</P>

<P>Functions for allocation and registering:</P>
<P>
<UL>
<LI><B>snd_pcm_t *snd_pcm_new_device( snd_card_t *card, char *id )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>id</B> identification for pcm device (for example 'AD1848')</LI>
</UL>
</LI>
<LI><B>int snd_pcm_free( snd_pcm_t *pcm )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI>frees pcm structure and associated private data</LI>
</UL>
</LI>
<LI><B>int snd_pcm_register( snd_pcm_t *pcm, int pcm_device )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI><B>pcm_device</B> number of pcm device (0-3)</LI>
<LI>registers pcm device</LI>
</UL>
</LI>
<LI><B>int snd_pcm_unregister( snd_pcm_t *pcm )</B>
<UL>
<LI><B>pcm</B> pointer to pcm structure</LI>
<LI>unregisters and frees pcm structure</LI>
</UL>
</LI>
</UL>
</P>


<H2><A NAME="ss5.2">5.2 Examples</A></H2>


<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
static struct snd_stru_pcm_hardware snd_es1688_playback = {
  NULL,                         /* private data */
  NULL,                         /* private_free */
  SND_PCM_HW_AUTODMA,           /* flags */
  SND_PCM_FMT_U8 | SND_PCM_FMT_S16_LE,  /* formats */
  0,                            /* align value */
  6,                            /* minimal fragment */
  4000,                         /* min. rate */
  48000,                        /* max. rate */
  2,                            /* max. voices */
  snd_es1688_playback_open,
  snd_es1688_playback_close,
  snd_es1688_playback_compute_rate,
  snd_es1688_playback_prepare,
  snd_es1688_playback_trigger,
  snd_es1688_playback_pointer,
  snd_pcm_playback_dma_ulaw,
  snd_pcm_dma_move,
  snd_pcm_playback_dma_neutral
};

static struct snd_stru_pcm_hardware snd_es1688_record = {
  NULL,                         /* private data */
  NULL,                         /* private free */
  SND_PCM_HW_AUTODMA,           /* flags */
  SND_PCM_FMT_U8 | SND_PCM_FMT_S16_LE,  /* formats */
  0,                            /* align value */
  6,                            /* minimal fragment */
  4000,                         /* min. rate */
  48000,                        /* max. rate */
  2,                            /* max. voices */
  snd_es1688_record_open,
  snd_es1688_record_close,
  snd_es1688_record_compute_rate,
  snd_es1688_record_prepare,
  snd_es1688_record_trigger,
  snd_es1688_record_pointer,
  snd_pcm_record_dma_ulaw,
  snd_pcm_dma_move,
  NULL
};

static void snd_es1688_free( void *private_data )
{
  snd_free( private_data, sizeof( es1688_t ) );
}

snd_pcm_t *snd_es1688_new_device( snd_card_t *card,
                                  unsigned short port,
                                  unsigned short mpu_port,
                                  unsigned short irqnum,
                                  unsigned short mpu_irqnum,
                                  unsigned short dma8num,
                                  unsigned short hardware )
{
  snd_pcm_t *pcm;
  es1688_t *codec;

  pcm = snd_pcm_new_device( card, &quot;ESx688&quot; );
  if ( !pcm ) return NULL;
  codec = (es1688_t *)snd_malloc( sizeof( es1688_t ) );
  if ( !codec ) return NULL;
  memset( codec, 0, sizeof( es1688_t ) );
  snd_spin_prepare( codec, reg );
  snd_spin_prepare( codec, mixer );
  codec -&gt; pcm = pcm;
  codec -&gt; card = pcm -&gt; card;
  codec -&gt; port = port;
  codec -&gt; mpu_port = mpu_port;
  codec -&gt; irqnum = irqnum;
  codec -&gt; irq = pcm -&gt; card -&gt; irqs[ irqnum ] -&gt; irq;
  codec -&gt; mpu_irqnum = mpu_irqnum;
  if ( mpu_irqnum != SND_IRQ_DISABLE )
    codec -&gt; mpu_irq = pcm -&gt; card -&gt; irqs[ mpu_irqnum ] -&gt; irq;
  codec -&gt; dma8num = dma8num;
  codec -&gt; dma8 = pcm -&gt; card -&gt; dmas[ dma8num ] -&gt; dma;
  codec -&gt; hardware = hardware;
  memcpy( &amp;pcm -&gt; playback.hw, &amp;snd_es1688_playback, sizeof( snd_es1688_playback ) );
  memcpy( &amp;pcm -&gt; record.hw, &amp;snd_es1688_record, sizeof( snd_es1688_record ) );
  pcm -&gt; private_data = codec;
  pcm -&gt; private_free = snd_es1688_free;
  pcm -&gt; info_flags = SND_PCM_INFO_CODEC | SND_PCM_INFO_MMAP |
                      SND_PCM_INFO_PLAYBACK | SND_PCM_INFO_RECORD;
  sprintf( pcm -&gt; name, &quot;ES%s688 rev %i&quot;, codec -&gt; hardware == ES1688_HW_688 ?&quot;&quot; : &quot;1&quot;, codec -&gt; version & 0x0f );
  if ( snd_es1688_probe( pcm ) &lt; 0 ) {
    snd_pcm_free( pcm );
    return NULL;
  }
  return pcm;
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>PCM device registering:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  snd_card_t *card;
  snd_pcm_t *pcm;

  pcm = snd_es1688_new_device( card, port, mpu_port, irqnum, mpu_irqnum, dma8num, ES1688_HW_AUTO );
  if ( !pcm ) return NULL;
  ...
  if ( snd_pcm_register( pcm, 0 ) ) {
    ... unregister already registered devices ...
    snd_pcm_free( pcm );
    snd_card_free( card );
    return -ENXIO;
  }
  ...
  snd_pcm_unregister( pcm );
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<HR>
<A HREF="coding-4.html">Previous</A>
Next
<A HREF="coding.html#toc5">Table of Contents</A>
</BODY>
</HTML>
