<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.7">
 <TITLE>Advanced Linux Sound Architecture - Driver: Introduction</TITLE>
 <LINK HREF="coding-2.html" REL=next>

 <LINK HREF="coding.html#toc1" REL=contents>
</HEAD>
<BODY>
<A HREF="coding-2.html">Next</A>
Previous
<A HREF="coding.html#toc1">Contents</A>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>This document describes the ALSA driver and kernel API. Application
programmers should use the library API rather than kernel API.
The ALSA Library offers 100% of the functionally of the kernel API, but add
next major improvements in usability, making the application code simpler and
better looking. In addition, some of the some fixes/compatibility code in,
may be placed in the library code instead of the kernel driver.
<P>
<P>
<H2><A NAME="ss1.1">1.1 Source files</A>
</H2>

<P>Source files are separated to:
<P>
<P>
<DL>
<DT><B>/include</B><DD><P>Directory contains all header files which are included from more sources.
<DT><B>/kernel</B><DD><P>Directory with kernel code and abstract layers (middle level code and library).
<DT><B>/lowlevel</B><DD><P>Generic lowlevel code for chip(set)s.
<DT><B>/cards</B><DD><P>Upper level for soundcards and specific lowlevel code.
<DT><B>/detect</B><DD><P>Detection layer (<I>/proc/asound/detect</I> - to make installation easy).
</DL>
<P>
<H2><A NAME="ss1.2">1.2 Devices</A>
</H2>

<P>Devices should use abstract code from sound kernel, but it should use
own code and register minors separetely (with snd_minor_register and
snd_minor_unregister functions). This method totaly bypass all abstract
code, so code for these soundcards must handle all things.
<P>
<H2><A NAME="ss1.3">1.3 Memory allocation</A>
</H2>

<P>
<UL>
<LI><B>void *snd_malloc( unsigned long size )</B></LI>
<LI><B>void snd_free( void *ptr, unsigned long size )</B></LI>
<LI><B>char *snd_malloc_strdup( char *string )</B></LI>
<LI><B>void snd_free_str( char *string )</B></LI>
</UL>
<P>These routines use their own memory allocation algoritm. It should be 
removed in the future and replaced with kmalloc and kfree calls, but
for now I need to trace all allocation problems to make code clean...
<P>Note: ALSA driver heavily uses dynamic allocation for most things.
<P>For debugging you should use command './configure --with-debug=full' for
configuration. This enables trace of allocated memory with above functions
and this makes debugging a little bit easier.
<P>
<H2><A NAME="ss1.4">1.4 Basic coding</A>
</H2>

<P>All things are made as objects (which encapsulates data and functions) and are
referenced in this way. I don't prefer to pass index to some array of structure
or something like this. Objects contain both data and functions.  Pointers to these
objects are passed around (like C++).
<P>All main structures should have snd_xxxx_new, snd_xxxx_free, snd_xxxx_register,
snd_xxxx_unregister functions.
<P>
<UL>
<LI><B>snd_card_t</B> is a basic structure which contains info about a soundcard,
index and resource tracking variables. Look at <I>include/driver.h</I>
for all things related to this structure.</LI>
</UL>
<P>
<UL>
<LI><B>snd_pcm_t</B> is a basic structure for a PCM device.</LI>
<LI><B>snd_pcm_channel_t</B> is a basic structure for a PCM channel (direction).</LI>
<LI><B>struct snd_stru_pcm_hardware</B> is a structure which must be filled
by lowlevel code. Look at <I>include/pcm.h</I> for all things
related to these structures.</LI>
</UL>
<P>
<UL>
<LI><B>snd_kmixer_t</B> is a basic structure for a MIXER device.</LI>
<LI><B>snd_kmixer_channel_t</B> is a basic structure for a MIXER channel.</LI>
<LI><B>struct snd_stru_mixer_channel_hw</B> is a structure which must be filled
by lowlevel code. Look at <I>include/mixer.h</I> for all things
related to these structures.</LI>
</UL>
<P>
<H2><A NAME="ss1.5">1.5 Upper level (/cards)</A>
</H2>

<P>Code for soundcards should contain these things:
<P>
<OL>
<LI>Support for more than one of the same soundcard (up to SND_CARDS)...
<UL>
<LI>it isn't really possible due to HW limitations</LI>
</UL>
</LI>
<LI>Autodetection/autoconfiguration feature (if it's possible)...
<UL>
<LI>if lowlevel code is specific for soundcard type - it should be here, too..</LI>
</UL>
</LI>
<LI>Initialization code for soundcard
<UL>
<LI>snd_card_new</LI>
<LI>snd_card_free (frees all hardware resources)</LI>
</UL>
</LI>
<LI>Allocate/free hardware resources for soundcard
<UL>
<LI>snd_register_ioport</LI>
<LI>snd_unregister_ioports (frees all ioports)</LI>
<LI>snd_register_interrupt</LI>
<LI>snd_unregister_interrupts (frees all interrupts)</LI>
<LI>snd_register_dma_channel</LI>
<LI>snd_unregister_dma_channels (frees all DMA channels)</LI>
</UL>
</LI>
<LI>Initialize other layers (PCMs, Mixers etc.)
<UL>
<LI>snd_pcm_new</LI>
<LI>snd_pcm_free</LI>
<LI>snd_pcm_register</LI>
<LI>snd_pcm_unregister (calls snd_pcm_free)</LI>
<LI>snd_mixer_new</LI>
<LI>snd_mixer_free</LI>
<LI>snd_mixer_register</LI>
<LI>snd_mixer_unregister (calls snd_mixer_free)</LI>
</UL>
</LI>
<LI>Register soundcard
<UL>
<LI>snd_card_register</LI>
<LI>snd_card_unregister (doesn't call snd_card_free)</LI>
</UL>
</LI>
</OL>
<P><B>Note:</B>
Due to module dependency you should separate code for soundcards
from the same manufacture which have slightly different hardware.
Example: The GUS Extreme has an ESS ES-1688 chip. This chip isn't in the GUS
Classic. For GUS Classic, the generic code in the snd-es1688.o module isn't
needed. So there are two upper level modules (snd-gusextreme.o and
snd-gusclassic.o).
<P>
<H2><A NAME="ss1.6">1.6 Private data/values</A>
</H2>

<P>Some structures have pointers to private data and values. These variables
aren't used with the abstract layers and are intended for low-level code
use only. 
<P>
<HR>
<PRE>
snd_card_t -> private_data
snd_card_t -> private_free (called from snd_card_free if not NULL)
</PRE>
<HR>
<P>
<HR>
<PRE>
struct snd_stru_pcm_hardware -> private_data
struct snd_stru_pcm_hardware -> private_free (called from snd_pcm_free if not NULL)
snd_pcm_t -> private_data
snd_pcm_t -> private_free (called from snd_pcm_free if not NULL)
</PRE>
<HR>
<P>
<HR>
<PRE>
struct snd_stru_mixer_channel_hw -> private_value
snd_kmixer_channel_t -> private_data
snd_kmixer_channel_t -> private_free (called from snd_mixer_free if not NULL)
snd_kmixer_t -> private_value
snd_kmixer_t -> private_data
snd_kmixer_t -> private_free (called from snd_mixer_free if not NULL)
</PRE>
<HR>
<P>
<H2><A NAME="ss1.7">1.7 CLI/STI &amp; spin locking</A>
</H2>

<P>Good code shouldn't contain <I>snd_cli()</I>/<I>snd_sti()</I> calls.
Instead use spin locks <I>snd_spin_lock()</I>/<I>snd_spin_unlock()</I>
for locking code. This method is much better for SMP machines.
<P><B>Note:</B> Debugging code is available for locking.  Look in 
<I>sndspinlock.h</I> to enable it.
<P>
<H2><A NAME="ss1.8">1.8 Examples</A>
</H2>

<P>You should look at the code for GUS soundcards to see how can be things done...
<P><B>Note:</B> Code should be compiled cleanly under 2.0.X kernels and under
latest 2.1.X kernels...
<P>
<P>
<P>
<HR>
<A HREF="coding-2.html">Next</A>
Previous
<A HREF="coding.html#toc1">Contents</A>
</BODY>
</HTML>
