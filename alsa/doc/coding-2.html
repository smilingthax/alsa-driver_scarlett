<HTML>
<HEAD>
<TITLE>Advanced Linux Sound Architecture - Driver: Soundcard</TITLE>
</HEAD>
<BODY>
<A HREF="coding-1.html">Previous</A>
<A HREF="coding-3.html">Next</A>
<A HREF="coding.html#toc2">Table of Contents</A>
<HR>
<H2><A NAME="s2">2. Soundcard</A></H2>

<P>Soundcard related structures and functions are in <I>include/driver.h</I>
header file. Structure <I>snd_card_t</I> must be allocated by
<I>snd_card_new</I> function and freed by <I>snd_card_free</I>
function (whis isn't called from <I>snd_card_unregister</I>).</P>

<H2><A NAME="ss2.1">2.1 Variables and functions</A></H2>

<P>Functions list:</P>
<P>
<UL>
<LI><B>snd_card_t *snd_card_new( int idx, char *id, void (*use_inc)( snd_card_t * ), void (*use_dec)( snd_card_t *) )</B>
<UL>
<LI><B>idx</B> soundcard index (order), 1-8 or -1 = first free</LI>
<LI><B>id</B> soundcard id, if NULL or '\0' -> default (card#)</LI>
<LI><B>inc_use</B> increment use of last soundcard module (to avoid remove)</LI>
<LI><B>dec_use</B> decrement use of last soundcard module (to allow remove)</LI>
<LI>returns NULL if not enough memory is available</LI>
</UL>
</LI>
<LI><B>int snd_card_free( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure to free</LI>
<LI>frees all registered resources (ports, IRQs and DMAs), too</LI>
<LI>returns negative value when error</LI>
</UL>
</LI>
<LI><B>int snd_card_register( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure to register; applications
should from this point use soundcard</LI>
<LI>returns negative value when error</LI>
</UL>
</LI>
<LI><B>int snd_card_unregister( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure to unregister; applications
aren't able from this point use soundcard</LI>
<LI>doesn't call <I>snd_card_free</I></LI>
<LI>returns negative value when error</LI>
</UL>
</LI>
</UL>
</P>

<P>Variables from <I>snd_card_t</I> structure which must be filled:</P>
<P>
<UL>
<LI><B>type</B> is type identification from <I>include/sounddetect.h</I>.</LI>
<LI><B>abbreviation</B> is abbreviation for soundcard (for example 'GUS').</LI>
<LI><B>shortname</B> is shortname for soundcard (for example 'Gravis UltraSound MAX').</LI>
<LI><B>longname</B> is full identification for soundcard (for example 'Gravis UltraSound MAX at 0x220, irq 5, dma 1&5').</LI>
</UL>
</P>

<P>Variables from <I>snd_card_t</I> structure which should be filled:</P>
<P>
<UL>
<LI><B>private_data</B> should be used by soundcard driver for private data.</LI>
<LI><B>private_free</B> is called when <I>private_data</I> should be freed.</LI>
</UL>
</P>

<H3>Examples</H3>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
static void snd_soundcard_use_inc( snd_card_t *card )
{
  MOD_INC_USE_COUNT;
}

static void snd_soundcard_use_dec( snd_card_t *card )
{
  MOD_DEC_USE_COUNT;
}

int snd_soundcard_init( void )
{
  snd_card_t *card;

  card = snd_card_new( -1, NULL, snd_soundcard_use_inc, snd_soundcard_dec_inc );
  if ( !card ) return -ENOMEM;
  card -&gt; type = SND_CARD_TYPE_SOUNDCARD;       /* can be changed later */

  ... resource initialization, detection, device creation and registration ...

  strcpy( card -&gt; abbreviation, &quot;SoundCard&quot; );
  strcpy( card -&gt; shortname, &quot;3-D SoundCard&quot; );
  strcpy( card -&gt; longname, &quot;3-D SoundCard at 0x500, irq 5, dma 5&6&quot; );

  if ( !snd_card_register( card ) )
    return 0;
  snd_card_free( card );

  return -ENXIO;
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.2">2.2 Resources</A></H2>

<P>Functions list:</P>
<P>
<UL>
<LI><B>int snd_register_ioport( snd_card_t *card, int port, int size, char *name )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>port</B> means first port from ioport region</LI>
<LI><B>size</B> means size of ioport region</LI>
<LI><B>name</B> ioport region name</LI>
<LI>registers ioport region and assigns it to soundcard</LI>
</UL>
</LI>
<LI><B>int snd_unregister_ioports( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI>unregisters all ioport regions which are assigned to soundcard</LI>
</UL>
</LI>
<LI><B>int snd_register_dma_channel( snd_card_t *card, char *name, int number, int type, int rsize, int *possible_numbers )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>name</B> name of dma channel</LI>
<LI><B>number</B> number of dma channel or <B>SND_AUTO_DMA</B></LI>
<LI><B>type</B> type of dma buffer
<UL>
<LI><B>SND_DMA_TYPE_ISA</B> limited dma buffer to low 16MB of RAM</LI>
<LI><B>SND_DMA_TYPE_PCI</B> unlimited dma buffer
(should be anywhere in RAM)</LI>
<LI><B>SND_DMA_TYPE_HARDWARE</B> hardware dma buffer
(is available on soundcard and directly mmaped to OS memory)</LI>
</UL>
</LI>
<LI><B>rsize</B> requested dma buffer size (in kB) or <B>SND_AUTO_DMA_SIZE</B></LI>
<LI><B>possible_numbers</B> pointer to int array which contains all
possible dma numbers for this channel terminated by -1; function
uses these values for verification of valid input from user or
if <B>SND_AUTO_DMA</B> is specified to detect first useable
dma channel</LI>
</UL>
</LI>
<LI><B>int snd_unregister_dma_channels( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI>unregisters all dma channels assigned to soundcard</LI>
</UL>
</LI>
<LI><B>int snd_register_interrupt( snd_card_t *card, char *name, int number, int type, snd_irq_handler_t *handler, void *dev_id, int *possible_numbers )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>name</B> name of interrupt line</LI>
<LI><B>number</B> number of interrupt line or <B>SND_AUTO_IRQ</B></LI>
<LI><B>type</B> type of interrupt line
<UL>
<LI><B>SND_IRQ_TYPE_ISA</B> ISA interrupt line (not shareable)</LI>
<LI><B>SND_IRQ_TYPE_PCI</B> PCI interrupt line (shareable)</LI>
</UL>
</LI>
<LI><B>handler</B> pointer to interrupt handler</LI>
<LI><B>dev_id</B> pointer to some private structure for interrupt handler</LI>
<LI><B>possible_numbers</B> pointer to int arrays which contains all
possible dma numbers for this channel terminated by -1; function
uses these values for verification of valid input from user or
if <B>SND_AUTO_IRQ</B> is specified to detect first useable
interrupt line</LI>
<LI>returns index to card -> irqs array</LI>
</UL>
</LI>
<LI><B>int snd_unregister_interrupts( snd_card_t *card )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI>disables and frees all interrupt lines assigned to soundcard</LI>
</UL>
</LI>
<LI><B>int snd_enable_irq( snd_card_t *card, int irqnum )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>irqnum</B> index of interrupt line to be enabled</LI>
</UL>
</LI>
<LI><B>int snd_disable_irq( snd_card_t *card, int irqnum )</B>
<UL>
<LI><B>card</B> pointer to soundcard structure</LI>
<LI><B>irqnum</B> index of interrupt line to be disabled</LI>
</UL>
</LI>
</UL>
</P>
<P><B>Note 1:</B> dma buffer must be assigned for all (PCI and other than ISA)
soundcards, too. ALSA kernel and OSS PCM midlevel code contains mechanism
for correct free when mmaped access was used. Buffer isn't allocated at
register time. Buffer is managed with functions <I>snd_dma_malloc</I>
and <I>snd_dma_free</I> when some device is opened/closed.</P>
<P><B>Note 2:</B> routines for interrupt line and dma channel registering
returns index do <I>snd_card_t -> irqs</I> and <I>snd_card_t -> dmas</I>
arrays. This value isn't equal to interrupt number or dma channel number,
but in driver <I>irqnum</I> or <I>dmanum</I> means irq or dma index 
(internal driver resource identification) and <I>irq</I> or <I>dma</I>
means real irq or dma number.</P>

<H3>Examples</H3>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
int snd_irq = SND_DEFAULT_IRQ1;
int snd_dma1 = SND_DEFAULT_DMA1;
int snd_dma1_size = SND_DEFAULT_DMA_SIZE1;

static snd_card_t *snd_card = NULL;
static int snd_irqnum = SND_IRQ_DISABLE;

static void snd_soundcard_interrupt1( int irq, void *dev_id, struct pt_regs *regs )
{
  ... interrupt handler ...
}

void snd_soundcard_init_resources( void )
{
#ifdef EXAMPLE_FOR_ISA_BUS
  static int possible_irqs[] = { 9, 10, 11, 7, -1 };
  static int possible_dmas[] = { 1, 3, 0, -1 };
 
  if ( (snd_irqnum = snd_register_interrupt( snd_card, &quot;SoundCard&quot;, snd_irq, SND_IRQ_TYPE_ISA, snd_soundcard_interrupt, NULL, possible_irqs )) &lt; 0 )
    return snd_irqnum;
  if ( (snd_dma1num = snd_register_dma_channel( snd_card, &quot;SoundCard&quot;, snd_dma1, SND_DMA_TYPE_ISA, snd_dma1_size, possible_dmas )) &lt; 0 )
    return snd_dma1num;
#else /* EXAMPLE_FOR_PCI_BUS */
  if ( (snd_irqnum = snd_register_interrupt( snd_card, &quot;SoundCard&quot;, snd_irq, SND_IRQ_TYPE_PCI, snd_soundcard_interrupt, NULL, NULL )) &lt; 0 )
    return snd_irqnum;
  if ( (snd_dma1num = snd_register_dma_channel( snd_card, &quot;SoundCard&quot;, snd_dma1, SND_DMA_TYPE_PCI, snd_dma1_size, NULL )) &lt; 0 )
    return snd_dma1num;
#endif
}

int snd_soundcard_probe( unsigned short port )
{
  if ( snd_register_ioport( snd_card, port, 8, &quot;SoundCard - Codec&quot; ) &lt; 0 )
    return -EBUSY;
  if ( snd_register_ioport( snd_card, port + 0x100, 16, &quot;SoundCard - Synthesizer&quot; ) &lt; 0 ) {
    snd_unregister_ioports( snd_card );
    return -EBUSY;
  }

  ... hardware probe here - if fails - snd_unregister_ioports!!! ...

  return 0;
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.3">2.3 ISA DMA</A></H2>

<P>Functions list:</P>
<P>
<UL>
<LI><B>void snd_dma_program( int dma, const void *buf, unsigned int size, unsigned char mode )</B>
<UL>
<LI><B>dma</B> dma number (not index)</LI>
<LI><B>buf</B> dma buffer</LI>
<LI><B>size</B> dma buffer size (transfer length)</LI>
<LI><B>mode</B> dma transfer mode
<UL>
<LI><B>DMA_MODE_READ</B></LI>
<LI><B>DMA_MODE_WRITE</B></LI>
<LI><B>DMA_MODE_AUTOINIT</B> - flag</LI>
</UL>
</LI>
<LI>programs dma transfer</LI>
</UL>
</LI>
<LI><B>unsigned int snd_dma_residue( int dma )</B>
<UL>
<LI><B>dma</B> dma number (not index)</LI>
<LI>returns residue value for specified dma channel</LI>
</UL>
</LI>
</UL>
</P>


<H2><A NAME="ss2.4">2.4 PCI bus</A></H2>

<P>PCI bus related structures and functions are in <I>include/sndpci.h</I>
header file. Functions are designated for use with both type of kernels
(2.0 and 2.1).</P>

<P>Read-only variables from <I>struct snd_pci_dev</I> structure which should
be used:</P>
<P>
<UL>
<LI><B>devfn</B> encoded device & function index</LI>
<LI><B>vendor</B> - see to <B>PCI_VENDOR_ID_*</B></LI>
<LI><B>device</B> - see to <B>PCI_DEVICE_ID_*</B></LI>
<LI><B>class</B> - 3 bytes (base, sub, prog-if)</LI>
<LI><B>master</B> - set if device is master capable</LI>
<LI><B>irq</B> - irq generated by this device (remaped if needed)</LI>
<LI><B>base_address</B> - base registers for this device (remaped if needed)</LI>
</UL>
</P>

<P>Functions list:</P>
<P>
<UL>
<LI><B>int snd_pci_find_device( unsigned int vendor, unsigned int device, unsigned int index, struct snd_pci_dev *dev );</B>
<UL>
<LI><B>vendor</B> identification (see to <B>PCI_VENDOR_ID_*</B>)</LI>
<LI><B>device</B> identification (see to <B>PCI_DEVICE_ID_*</B>)</LI>
<LI><B>index</B> device index (0-X) for which is information requested</LI>
<LI><B>dev</B> pointer to PCI device structure (not same as in kernel)</LI>
</UL>
</LI>
<LI><B>int snd_pci_read_config_byte( struct snd_pci_dev *dev, unsigned char where, unsigned char *val )</B></LI>
<LI><B>int snd_pci_read_config_word( struct snd_pci_dev *dev, unsigned char where, unsigned short *val )</B></LI>
<LI><B>int snd_pci_read_config_dword( struct snd_pci_dev *dev, unsigned char where, unsigned int *val )</B>
<UL>
<LI>read byte/word/dword from PCI configuration registers</LI>
</UL>
</LI>
<LI><B>int snd_pci_write_config_byte( struct snd_pci_dev *dev, unsigned char where, unsigned char val )</B></LI>
<LI><B>int snd_pci_write_config_word( struct snd_pci_dev *dev, unsigned char where, unsigned short val )</B></LI>
<LI><B>int snd_pci_write_config_dword( struct snd_pci_dev *dev, unsigned char where, unsigned int val )</B>
<UL>
<LI>write byte/word/dword to PCI configuration registers</LI>
</UL>
</LI>
</UL>
</P>

<H3>Examples</H3>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  struct snd_pci_dev pci_dev;   /* use heap for this variable */
  unsigned short cmd;

  if ( snd_pci_find_device( PCI_VENDOR_ID_ENSONIQ,
                            PCI_DEVICE_ID_ENSONIQ_AUDIOPCI,
                            0,
                            &amp;pci_dev ) &lt; 0 )
    return -ENODEV;
  snd_printk( &quot;First Ensoniq PCI soundcard found at 0x%x and irq %i\n&quot;,
                pci_dev -&gt; base_address[ 0 ] & ~3,
                pci_dev -&gt; irq );
  snd_printk( &quot;enabling Master..\n&quot; );
  snd_pci_read_config_word( &amp;pci_dev, PCI_COMMAND, &amp;cmd );
  cmd |= PCI_COMMAND_IO | PCI_COMMAND_MASTER;
  snd_pci_write_config_word( &amp;pci_dev, PCI_COMMAND, cmd );
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>



<HR>
<A HREF="coding-1.html">Previous</A>
<A HREF="coding-3.html">Next</A>
<A HREF="coding.html#toc2">Table of Contents</A>
</BODY>
</HTML>
