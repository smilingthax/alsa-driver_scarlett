--- ../alsa-kernel/core/init.c	2005-10-31 13:57:30.000000000 +0100
+++ init.c	2005-10-31 14:05:14.000000000 +0100
@@ -1,3 +1,4 @@
+#define __NO_VERSION__
 /*
  *  Initialization routines
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
@@ -193,7 +194,9 @@
 		f_ops = &s_f_ops->f_ops;
 
 		memset(f_ops, 0, sizeof(*f_ops));
+#ifndef LINUX_2_2
 		f_ops->owner = file->f_op->owner;
+#endif
 		f_ops->release = file->f_op->release;
 		f_ops->poll = snd_disconnect_poll;
 
@@ -663,6 +666,7 @@
 }
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 /*
  * generic device without a proper bus using platform_device
  * (e.g. ISA)
@@ -677,9 +681,14 @@
 #define SND_GENERIC_NAME	"snd_generic"
 
 #ifdef CONFIG_PM
+#ifdef CONFIG_SND_OLD_DRIVER_SUSPEND
+static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level);
+static int snd_generic_resume(struct device *dev, u32 level);
+#else
 static int snd_generic_suspend(struct device *dev, pm_message_t state);
 static int snd_generic_resume(struct device *dev);
 #endif
+#endif
 
 /* initialized in sound.c */
 struct device_driver snd_generic_driver = {
@@ -750,6 +759,24 @@
 		snd_card_set_dev(card, &card->generic_dev->pdev.dev);
 	return 0;
 }
+#else /* < 2.6.0 */
+
+int snd_card_set_generic_dev(snd_card_t *card)
+{
+	return 0;
+}
+
+static void snd_generic_device_unregister(snd_card_t *card)
+{
+#ifdef CONFIG_PM
+	if (card->generic_dev) {
+		pm_unregister((struct pm_dev *)card->generic_dev);
+		card->generic_dev = NULL;
+	}
+#endif
+}
+
+#endif /* 2.6.0 */
 #endif /* CONFIG_SND_GENERIC_DRIVER */
 
 #ifdef CONFIG_PM
@@ -818,11 +845,20 @@
 }
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 /* suspend/resume callbacks for snd_generic platform device */
+#ifdef CONFIG_SND_OLD_DRIVER_SUSPEND
+static int snd_generic_suspend(struct device *dev, pm_message_t state, u32 level)
+#else
 static int snd_generic_suspend(struct device *dev, pm_message_t state)
+#endif
 {
 	snd_card_t *card;
 
+#ifdef CONFIG_SND_OLD_DRIVER_SUSPEND
+	if (level != SUSPEND_DISABLE)
+		return 0;
+#endif
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
 		return 0;
@@ -832,10 +868,18 @@
 	return 0;
 }
 
+#ifdef CONFIG_SND_OLD_DRIVER_SUSPEND
+static int snd_generic_resume(struct device *dev, u32 level)
+#else
 static int snd_generic_resume(struct device *dev)
+#endif
 {
 	snd_card_t *card;
 
+#ifdef CONFIG_SND_OLD_DRIVER_SUSPEND
+	if (level != RESUME_ENABLE)
+		return 0;
+#endif
 	card = get_snd_generic_card(dev);
 	if (card->power_state == SNDRV_CTL_POWER_D0)
 		return 0;
@@ -866,9 +910,83 @@
 		return err;
 	return snd_card_set_pm_callback(card, suspend, resume, private_data);
 }
+
+#else /* 2.4.x */
+
+static int snd_generic_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	snd_card_t *card = dev->data;
+	switch (rqst) {
+	case PM_SUSPEND:
+		if (card->power_state == SNDRV_CTL_POWER_D3hot)
+			break;
+		/* FIXME: the correct state value? */
+		card->pm_suspend(card, PMSG_SUSPEND);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+		break;
+	case PM_RESUME:
+		if (card->power_state == SNDRV_CTL_POWER_D0)
+			break;
+		/* FIXME: the correct state value? */
+		card->pm_resume(card);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+		break;
+	}
+	return 0;
+}
+
+int snd_card_set_generic_pm_callback(snd_card_t *card,
+				 int (*suspend)(snd_card_t *, pm_message_t),
+				 int (*resume)(snd_card_t *),
+				 void *private_data)
+{
+	struct pm_dev *pm_dev;
+
+	pm_dev = pm_register(PM_UNKNOWN_DEV, 0, snd_generic_pm_callback);
+	if (! pm_dev)
+		return -ENOMEM;
+	pm_dev->data = card;
+	card->generic_dev = (struct snd_generic_device *)pm_dev;
+	snd_card_set_pm_callback(card, suspend, resume, private_data);
+	return 0;
+}
+#endif /* 2.6.0 */
 #endif /* CONFIG_SND_GENERIC_DRIVER */
 
 #ifdef CONFIG_PCI
+#ifndef CONFIG_HAVE_PCI_SAVED_CONFIG
+static unsigned int pci_saved_config[SNDRV_CARDS][16];
+#endif
+#ifdef PCI_OLD_SUSPEND
+void snd_card_pci_suspend(struct pci_dev *dev)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	if (! card || ! card->pm_suspend)
+		return;
+	if (card->power_state == SNDRV_CTL_POWER_D3hot)
+		return;
+	/* FIXME: correct state value? */
+	card->pm_suspend(card, PMSG_SUSPEND);
+	pci_save_state(dev, &pci_saved_config[card->number][0]);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+}
+
+void snd_card_pci_resume(struct pci_dev *dev)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	if (! card || ! card->pm_resume)
+		return;
+	if (card->power_state == SNDRV_CTL_POWER_D0)
+		return;
+	/* restore the PCI config space */
+	pci_restore_state(dev, &pci_saved_config[card->number][0]);
+	/* FIXME: correct state value? */
+	card->pm_resume(card);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+}
+
+#else /* new suspend */
+
 int snd_card_pci_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	snd_card_t *card = pci_get_drvdata(dev);
@@ -878,7 +996,11 @@
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
 		return 0;
 	err = card->pm_suspend(card, PMSG_SUSPEND);
+#ifndef CONFIG_HAVE_PCI_SAVED_CONFIG
+	pci_save_state(dev, &pci_saved_config[card->number][0]);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
 	pci_save_state(dev);
+#endif
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	return err;
 }
@@ -891,11 +1013,19 @@
 	if (card->power_state == SNDRV_CTL_POWER_D0)
 		return 0;
 	/* restore the PCI config space */
+#ifndef CONFIG_HAVE_PCI_SAVED_CONFIG
+	pci_restore_state(dev, &pci_saved_config[card->number][0]);
+#elif defined(CONFIG_HAVE_NEW_PCI_SAVE_STATE)
 	pci_restore_state(dev);
+#else
+ 	pci_restore_state(dev, dev->saved_config_space);
+#endif
 	card->pm_resume(card);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-#endif
+
+#endif /* PCI_OLD_SUSPEND */
+#endif /* CONFIG_PCI */
 
 #endif /* CONFIG_PM */
