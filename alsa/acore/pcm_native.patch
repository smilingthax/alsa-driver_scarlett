--- ../alsa-kernel/core/pcm_native.c	2004-06-29 12:55:17.472672858 +0200
+++ pcm_native.c	2004-06-29 15:46:07.957852717 +0200
@@ -1,3 +1,4 @@
+#define __NO_VERSION__
 /*
  *  Digital Audio (PCM) abstract layer
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
@@ -2728,6 +2729,9 @@
 	snd_pcm_runtime_t *runtime;
 	snd_pcm_sframes_t result;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+	up(&file->f_dentry->d_inode->i_sem);
+#endif
 	pcm_file = file->private_data;
 	substream = pcm_file->substream;
 	snd_assert(substream != NULL, result = -ENXIO; goto end);
@@ -2745,9 +2749,13 @@
 	if (result > 0)
 		result = frames_to_bytes(runtime, result);
  end:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+	down(&file->f_dentry->d_inode->i_sem);
+#endif
 	return result;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 44)
 static ssize_t snd_pcm_readv(struct file *file, const struct iovec *_vector,
 			     unsigned long count, loff_t * offset)
 
@@ -2794,6 +2802,9 @@
 	void __user **bufs;
 	snd_pcm_uframes_t frames;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+	up(&file->f_dentry->d_inode->i_sem);
+#endif
 	pcm_file = file->private_data;
 	substream = pcm_file->substream;
 	snd_assert(substream != NULL, result = -ENXIO; goto end);
@@ -2818,8 +2829,12 @@
 		result = frames_to_bytes(runtime, result);
 	kfree(bufs);
  end:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+	down(&file->f_dentry->d_inode->i_sem);
+#endif
 	return result;
 }
+#endif
 
 unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait)
 {
@@ -2901,7 +2916,24 @@
 	return mask;
 }
 
+#ifndef VM_RESERVED
+#ifndef LINUX_2_2
+static int snd_pcm_mmap_swapout(struct page * page, struct file * file)
+#else
+static int snd_pcm_mmap_swapout(struct vm_area_struct * area, struct page * page)
+#endif
+{
+       return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 static struct page * snd_pcm_mmap_status_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+static struct page * snd_pcm_mmap_status_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#else
+static unsigned long snd_pcm_mmap_status_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#endif
 {
 	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
 	snd_pcm_runtime_t *runtime;
@@ -2913,9 +2945,15 @@
 	page = virt_to_page(runtime->status);
 	if (!PageReserved(page))
 		get_page(page);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 	if (type)
 		*type = VM_FAULT_MINOR;
+#endif
+#ifndef LINUX_2_2
 	return page;
+#else
+	return page_address(page);
+#endif
 }
 
 static struct vm_operations_struct snd_pcm_vm_ops_status =
@@ -2936,12 +2974,24 @@
 	if (size != PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)))
 		return -EINVAL;
 	area->vm_ops = &snd_pcm_vm_ops_status;
+#ifndef LINUX_2_2
 	area->vm_private_data = substream;
+#else
+	area->vm_private_data = (long)substream;	
+#endif
+#ifdef VM_RESERVED
 	area->vm_flags |= VM_RESERVED;
+#endif
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 static struct page * snd_pcm_mmap_control_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+static struct page * snd_pcm_mmap_control_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#else
+static unsigned long snd_pcm_mmap_control_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#endif
 {
 	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
 	snd_pcm_runtime_t *runtime;
@@ -2953,9 +3003,15 @@
 	page = virt_to_page(runtime->control);
 	if (!PageReserved(page))
 		get_page(page);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 	if (type)
 		*type = VM_FAULT_MINOR;
+#endif
+#ifndef LINUX_2_2
 	return page;
+#else
+	return page_address(page);
+#endif
 }
 
 static struct vm_operations_struct snd_pcm_vm_ops_control =
@@ -2976,8 +3032,14 @@
 	if (size != PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t)))
 		return -EINVAL;
 	area->vm_ops = &snd_pcm_vm_ops_control;
+#ifndef LINUX_2_2
 	area->vm_private_data = substream;
+#else
+	area->vm_private_data = (long)substream;	
+#endif
+#ifdef VM_RESERVED
 	area->vm_flags |= VM_RESERVED;
+#endif
 	return 0;
 }
 
@@ -2993,7 +3055,13 @@
 	atomic_dec(&substream->runtime->mmap_count);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 static struct page * snd_pcm_mmap_data_nopage(struct vm_area_struct *area, unsigned long address, int *type)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0)
+static struct page * snd_pcm_mmap_data_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#else
+static unsigned long snd_pcm_mmap_data_nopage(struct vm_area_struct *area, unsigned long address, int no_share)
+#endif
 {
 	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)area->vm_private_data;
 	snd_pcm_runtime_t *runtime;
@@ -3005,7 +3073,11 @@
 	if (substream == NULL)
 		return NOPAGE_OOM;
 	runtime = substream->runtime;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 25)
 	offset = area->vm_pgoff << PAGE_SHIFT;
+#else
+	offset = area->vm_offset;
+#endif
 	offset += address - area->vm_start;
 	snd_assert((offset % PAGE_SIZE) == 0, return NOPAGE_OOM);
 	dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
@@ -3021,9 +3093,15 @@
 	}
 	if (!PageReserved(page))
 		get_page(page);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 	if (type)
 		*type = VM_FAULT_MINOR;
+#endif
+#ifndef LINUX_2_2
 	return page;
+#else
+	return page_address(page);
+#endif
 }
 
 static struct vm_operations_struct snd_pcm_vm_ops_data =
@@ -3031,6 +3109,9 @@
 	.open =		snd_pcm_mmap_data_open,
 	.close =	snd_pcm_mmap_data_close,
 	.nopage =	snd_pcm_mmap_data_nopage,
+#ifndef VM_RESERVED
+	.swapout =	snd_pcm_mmap_swapout,
+#endif
 };
 
 static struct vm_operations_struct snd_pcm_vm_ops_data_mmio =
@@ -3064,7 +3145,11 @@
 	    runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
 		return -EINVAL;
 	size = area->vm_end - area->vm_start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 25)
 	offset = area->vm_pgoff << PAGE_SHIFT;
+#else
+	offset = area->vm_offset;
+#endif
 	dma_bytes = PAGE_ALIGN(runtime->dma_bytes);
 	if ((size_t)size > dma_bytes)
 		return -EINVAL;
@@ -3072,14 +3157,28 @@
 		return -EINVAL;
 
 	area->vm_ops = &snd_pcm_vm_ops_data;
+#ifndef LINUX_2_2
 	area->vm_private_data = substream;
+#else
+	area->vm_private_data = (long)substream;
+#endif
+#ifdef VM_RESERVED
 	area->vm_flags |= VM_RESERVED;
+#endif
 	if (runtime->hw.info & SNDRV_PCM_INFO_MMAP_IOMEM) {
 		area->vm_ops = &snd_pcm_vm_ops_data_mmio;
 		area->vm_flags |= VM_IO;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
+#define io_remap_page_range remap_page_range
+#endif
+		if (io_remap_page_range(area->vm_start, runtime->dma_addr + offset,
+					size, area->vm_page_prot))
+#else
 		if (io_remap_page_range(area, area->vm_start,
 					runtime->dma_addr + offset,
 					size, area->vm_page_prot))
+#endif
 			return -EAGAIN;
 	}
 	atomic_inc(&runtime->mmap_count);
@@ -3096,7 +3195,11 @@
 	substream = pcm_file->substream;
 	snd_assert(substream != NULL, return -ENXIO);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 25)
 	offset = area->vm_pgoff << PAGE_SHIFT;
+#else
+	offset = area->vm_offset;
+#endif
 	switch (offset) {
 	case SNDRV_PCM_MMAP_OFFSET_STATUS:
 		return snd_pcm_mmap_status(substream, file, area);
@@ -3241,9 +3344,13 @@
  */
 
 static struct file_operations snd_pcm_f_ops_playback = {
+#ifndef LINUX_2_2
 	.owner =	THIS_MODULE,
+#endif
 	.write =	snd_pcm_write,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 44)
 	.writev =	snd_pcm_writev,
+#endif
 	.open =		snd_pcm_open,
 	.release =	snd_pcm_release,
 	.poll =		snd_pcm_playback_poll,
@@ -3253,9 +3360,13 @@
 };
 
 static struct file_operations snd_pcm_f_ops_capture = {
+#ifndef LINUX_2_2
 	.owner =	THIS_MODULE,
+#endif
 	.read =		snd_pcm_read,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 44)
 	.readv =	snd_pcm_readv,
+#endif
 	.open =		snd_pcm_open,
 	.release =	snd_pcm_release,
 	.poll =		snd_pcm_capture_poll,
